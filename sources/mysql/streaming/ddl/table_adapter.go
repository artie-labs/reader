package ddl

import (
	"fmt"
	"github.com/artie-labs/reader/config"
	"github.com/artie-labs/reader/lib/debezium/transformer"
	"github.com/artie-labs/reader/lib/mysql/converters"
	"github.com/artie-labs/reader/lib/mysql/schema"
	"github.com/artie-labs/reader/lib/rdbms/column"
)

type Column struct {
	Name       string
	DataType   string
	PrimaryKey bool
}

type TableAdapter struct {
	dbName   string
	tableCfg *config.MySQLTable
	columns  []Column
	unixTs   int64

	// Generated by helper functions
	fieldConverters []transformer.FieldConverter
	parsedColumns   []schema.Column
}

func (t TableAdapter) ShouldReplicate() bool {
	return t.tableCfg != nil
}

func (t TableAdapter) GetUnixTs() int64 {
	return t.unixTs
}

func NewTableAdapter(dbName string, tableCfg *config.MySQLTable, columns []Column, unixTs int64) (TableAdapter, error) {
	tblAdapter := TableAdapter{
		dbName:   dbName,
		tableCfg: tableCfg,
		columns:  columns,
		unixTs:   unixTs,
	}

	return tblAdapter.buildGeneratedFields()
}

func (t TableAdapter) buildGeneratedFields() (TableAdapter, error) {
	parsedCols, err := t.buildParsedColumns()
	if err != nil {
		return TableAdapter{}, fmt.Errorf("failed to build parsed columns: %w", err)
	}

	t.parsedColumns = parsedCols
	fieldConverters, err := t.buildFieldConverters()
	if err != nil {
		return TableAdapter{}, fmt.Errorf("failed to build field converters: %w", err)
	}

	t.fieldConverters = fieldConverters
	return t, nil
}

func (t TableAdapter) buildFieldConverters() ([]transformer.FieldConverter, error) {
	if t.tableCfg == nil {
		return nil, nil
	}

	// Exclude columns (if any) from the table metadata
	cols, err := column.FilterOutExcludedColumns(t.GetParsedColumns(), t.tableCfg.ExcludeColumns, t.PartitionKeys())
	if err != nil {
		return nil, err
	}

	// Include columns (if any) from the table metadata
	cols, err = column.FilterForIncludedColumns(cols, t.tableCfg.IncludeColumns, t.PartitionKeys())
	if err != nil {
		return nil, err
	}

	fieldConverters := make([]transformer.FieldConverter, len(cols))
	for i, col := range cols {
		converter, err := converters.ValueConverterForType(col.Type, col.Opts)
		if err != nil {
			return nil, fmt.Errorf("failed to build value converter for column %q: %w", col.Name, err)
		}
		fieldConverters[i] = transformer.FieldConverter{Name: col.Name, ValueConverter: converter}
	}

	return fieldConverters, nil
}

func (t TableAdapter) buildParsedColumns() ([]schema.Column, error) {
	var parsedColumns []schema.Column
	for _, col := range t.columns {
		dataType, opts, err := schema.ParseColumnDataType(col.DataType)
		if err != nil {
			return nil, fmt.Errorf("failed to parse column data type: %w", err)
		}

		parsedColumns = append(parsedColumns, schema.Column{
			Name: col.Name,
			Type: dataType,
			Opts: opts,
		})
	}

	return parsedColumns, nil
}

func (t TableAdapter) TopicSuffix() string {
	return fmt.Sprintf("%s.%s", t.dbName, t.tableCfg.Name)
}

func (t TableAdapter) ColumnNames() []string {
	var colNames []string
	for _, col := range t.columns {
		colNames = append(colNames, col.Name)
	}

	return colNames
}

func (t TableAdapter) PartitionKeys() []string {
	var keys []string
	for _, col := range t.columns {
		if col.PrimaryKey {

			keys = append(keys, col.Name)
		}
	}

	return keys
}

func (t TableAdapter) GetParsedColumns() []schema.Column {
	return t.parsedColumns
}

func (t TableAdapter) GetFieldConverters() []transformer.FieldConverter {
	return t.fieldConverters
}
