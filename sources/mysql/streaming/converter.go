package streaming

import (
	"fmt"
	"iter"
	"regexp"
	"slices"
	"time"

	"github.com/artie-labs/transfer/lib/cdc/util"
	"github.com/go-mysql-org/go-mysql/replication"

	"github.com/artie-labs/reader/lib/mysql/schema"
)

// ddlFilterPatterns is sourced from https://github.com/debezium/debezium/blob/8ce74a328df6a6f99fb80826630a9d9b1d9022de/debezium-core/src/main/java/io/debezium/relational/history/SchemaHistory.java#L76
var ddlFilterPatterns = []*regexp.Regexp{
	regexp.MustCompile(`^(BEGIN|COMMIT)$`),
	regexp.MustCompile(`DROP TEMPORARY TABLE IF EXISTS .+ /\* generated by server \*/`),
	regexp.MustCompile(`(SET STATEMENT .*)?INSERT INTO (mysql\.)?rds_heartbeat2\(.*\) values \(.*\) ON DUPLICATE KEY UPDATE value = .*`),
	regexp.MustCompile(`(SET STATEMENT .*)?DELETE FROM (mysql\.)?rds_sysinfo.*`),
	regexp.MustCompile(`(SET STATEMENT .*)?INSERT INTO (mysql\.)?rds_sysinfo\(.*\) values \(.*\)`),
	regexp.MustCompile(`(SET STATEMENT .*)?INSERT INTO (mysql\.)?rds_monitor\(.*\) values \(.*\) ON DUPLICATE KEY UPDATE value = .*`),
	regexp.MustCompile(`(SET STATEMENT .*)?INSERT INTO (mysql\.)?rds_monitor\(.*\) values \(.*\)`),
	regexp.MustCompile(`(SET STATEMENT .*)?DELETE FROM (mysql\.)?rds_monitor.*`),
	regexp.MustCompile(`FLUSH RELAY LOGS.*`),
	regexp.MustCompile(`flush relay logs.*`),
	regexp.MustCompile(`SAVEPOINT .*`),
	regexp.MustCompile(`^\s*#\s*Dummy event.*`),
}

func shouldSkipDDL(query string) bool {
	for _, pattern := range ddlFilterPatterns {
		if pattern.MatchString(query) {
			return true
		}
	}

	return false
}

func preprocessRow(row map[string]any, parsedColumns []schema.Column) (map[string]any, error) {
	out := make(map[string]any)
	if len(row) == 0 {
		return out, nil
	}

	for _, col := range parsedColumns {
		val, ok := row[col.Name]
		if !ok {
			return nil, fmt.Errorf("column %q not found in row", col.Name)
		}

		parsedValue, err := schema.ConvertValue(val, col.Type, col.Opts)
		if err != nil {
			return nil, fmt.Errorf("failed to convert value '%v': %w", val, err)
		}

		out[col.Name] = parsedValue
	}

	return out, nil
}

func convertHeaderToOperation(evtType replication.EventType) (string, error) {
	switch evtType {
	case replication.WRITE_ROWS_EVENTv2:
		return "c", nil
	case replication.UPDATE_ROWS_EVENTv2:
		return "u", nil
	case replication.DELETE_ROWS_EVENTv2:
		return "d", nil
	default:
		return "", fmt.Errorf("unexpected event type %T", evtType)
	}
}

func getTimeFromEvent(evt *replication.BinlogEvent) time.Time {
	if evt == nil {
		return time.Time{}
	}

	// MySQL binlog only has second precision.
	return time.Unix(int64(evt.Header.Timestamp), 0)
}

// zipSlicesToMap creates a map from two slices, one of keys and one of values.
func zipSlicesToMap[K comparable, V any](keys []K, values []V) (map[K]V, error) {
	if len(values) != len(keys) {
		return nil, fmt.Errorf("keys length (%d) is different from values length (%d)", len(keys), len(values))
	}

	out := map[K]V{}
	for i, value := range values {
		out[keys[i]] = value
	}
	return out, nil
}

func splitIntoBeforeAndAfter(operation string, rows [][]any) (iter.Seq2[[]any, []any], error) {
	switch operation {
	case "c":
		return func(yield func([]any, []any) bool) {
			for _, row := range rows {
				if !yield(nil, row) {
					return
				}
			}
		}, nil
	case "u":
		// For updates, every modified row is present in the event rows, first as the row before the change and second,
		// as the row after the change.
		// We're assuming that this ordering of rows is consistent.
		if len(rows)%2 != 0 {
			return nil, fmt.Errorf("update row count is not divisible by two: %d", len(rows))
		}

		return func(yield func([]any, []any) bool) {
			for group := range slices.Chunk(rows, 2) {
				if !yield(group[0], group[1]) {
					return
				}
			}
		}, nil
	case "d":
		return func(yield func([]any, []any) bool) {
			for _, row := range rows {
				if !yield(row, nil) {
					return
				}
			}
		}, nil
	default:
		return nil, fmt.Errorf("unsupported operation: %q", operation)
	}
}

func buildDebeziumSourcePayload(dbName string, tableName string, ts time.Time, position Position) util.Source {
	return util.Source{
		Connector: "mysql",
		Database:  dbName,
		Table:     tableName,
		TsMs:      ts.UnixMilli(),

		// MySQL specific
		File: position.File,
		Pos:  int64(position.Pos),
	}
}
